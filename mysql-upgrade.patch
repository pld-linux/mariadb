--- mysql-5.1.22-rc/client/mysql_upgrade.c	2007-09-24 13:30:24.000000000 +0300
+++ mysql-5.1.22-rc-upgrade/client/mysql_upgrade.c	2008-01-12 17:28:56.945615880 +0200
@@ -31,12 +31,12 @@
 # endif
 #endif
 
-static char mysql_path[FN_REFLEN];
-static char mysqlcheck_path[FN_REFLEN];
+static char *mysql_path = "/usr/bin/mysql";
+static char *mysqlcheck_path = "/usr/sbin/mysqlcheck";
 
 static my_bool opt_force, opt_verbose, debug_info_flag, debug_check_flag;
 static uint my_end_arg= 0;
-static char *opt_user= (char*)"root";
+static char *opt_user= (char*)"mysql";
 
 static DYNAMIC_STRING ds_args;
 
@@ -349,91 +349,6 @@
   DBUG_RETURN(ret);
 }
 
-
-/*
-  Look for the tool in the same directory as mysql_upgrade.
-
-  When running in a not yet installed build the the program
-  will exist but it need to be invoked via it's libtool wrapper.
-  Check if the found tool can executed and if not look in the
-  directory one step higher up where the libtool wrapper normally
-  is found
-*/
-
-static void find_tool(char *tool_path, const char *tool_name)
-{
-  char path[FN_REFLEN];
-  DYNAMIC_STRING ds_tmp;
-  DBUG_ENTER("find_tool");
-  DBUG_PRINT("enter", ("progname: %s", my_progname));
-
-  if (init_dynamic_string(&ds_tmp, "", 32, 32))
-    die("Out of memory");
-
-  /* Initialize path with the full path to this program */
-  if (get_full_path_to_executable(path))
-  {
-    /*
-      Easy way to get full executable path failed, try
-      other methods
-    */
-    if (my_progname[0] == FN_LIBCHAR)
-    {
-      /* 1. my_progname contains full path */
-      strmake(path, my_progname, FN_REFLEN);
-    }
-    else if (my_progname[0] == '.')
-    {
-      /* 2. my_progname contains relative path, prepend wd */
-      char buf[FN_REFLEN];
-      my_getwd(buf, FN_REFLEN, MYF(0));
-      my_snprintf(path, FN_REFLEN, "%s%s", buf, my_progname);
-    }
-    else
-    {
-      /* 3. Just go for it and hope tool is in path */
-      path[0]= 0;
-    }
-  }
-  do
-  {
-    size_t path_len;
-    DBUG_PRINT("enter", ("path: %s", path));
-
-    /* Chop off last char(since it might be a /) */
-    path[max((strlen(path)-1), 0)]= 0;
-
-    /* Chop off last dir part */
-    dirname_part(path, path, &path_len);
-
-    /* Format name of the tool to search for */
-    fn_format(tool_path, tool_name,
-              path, "", MYF(MY_REPLACE_DIR));
-
-    verbose("Looking for '%s' in: %s", tool_name, tool_path);
-
-    /* Make sure the tool exists */
-    if (my_access(tool_path, F_OK) != 0)
-      die("Can't find '%s'", tool_path);
-
-    /*
-      Make sure it can be executed, otherwise try again
-      in higher level directory
-    */
-  }
-  while(run_tool(tool_path,
-                 &ds_tmp, /* Get output from command, discard*/
-                 "--help",
-                 "2>&1",
-                 IF_WIN("> NUL", "> /dev/null"),
-                 NULL));
-
-  dynstr_free(&ds_tmp);
-
-  DBUG_VOID_RETURN;
-}
-
-
 /*
   Run query using "mysql"
 */
@@ -758,12 +673,6 @@
   dynstr_append_os_quoted(&ds_args, "--user=", opt_user, NullS);
   dynstr_append(&ds_args, " ");
 
-  /* Find mysql */
-  find_tool(mysql_path, IF_WIN("mysql.exe", "mysql"));
-
-  /* Find mysqlcheck */
-  find_tool(mysqlcheck_path, IF_WIN("mysqlcheck.exe", "mysqlcheck"));
-
   /*
     Read the mysql_upgrade_info file to check if mysql_upgrade
     already has been run for this installation of MySQL
